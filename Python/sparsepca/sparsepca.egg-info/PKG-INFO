Metadata-Version: 2.1
Name: sparsepca
Version: 0.1.2
Summary: Sparse Principal Component Analysis in Python
Home-page: UNKNOWN
Author: Justin Huang, Benjamin Jochem, Shiqian Ma, and Lingzhou Xue
Author-email: lingzhou@psu.edu
License: UNKNOWN
Platform: UNKNOWN
Classifier: Programming Language :: Python :: 3
Classifier: License :: OSI Approved :: MIT License
Classifier: Operating System :: OS Independent
Requires-Python: >=3.8
Description-Content-Type: text/markdown
License-File: LICENSE

Uses an alternating manifold proximal gradient (AManPG) method to find sparse principal component loadings from the given data or covariance matrix. 

Requires numpy to be installed.

## Usage

```python
spca(b, mu, lamb, f_palm, 
     x0=None, y0=None, n=0, gamma=0.5, type=0, 
     maxiter=1e4, tol=1e-5, norm=True, verbose=False):
```

## Arguments

| Name | Type | Description |
| --- | --- | --- |
| `b` | numpy.ndarray | Either the data matrix or sample covariance matrix |
| `mu` | float list | List of parameters of length n for L1-norm penalty |
| `lamb` | float or numpy.inf | L2-norm penalty term |
| `f_palm` | float | Upper bound for the F-value to reach convergence |
| `x0` | numpy.ndarray | Initial x-values for the gradient method, default value is the first n right singular vectors |
| `y0` | numpy.ndarray | Initial y-values for the gradient method, default value is the first n right singular vectors |
| `n` | int | Number of principal components desired, default is 0 (returns min(n-1, p) principal components) |
| `gamma` | float | Parameter to control how quickly the step size changes in each iteration, default is 0.5 |
| `type` | int | If 0, b is expected to be a data matrix, and otherwise b is expected to be a covariance matrix; default is 0 |
| `maxiter` | int | Maximum number of iterations allowed in the gradient method, default is 1e4 |
| `tol` | float | Tolerance value required to indicate convergence (calculated as difference between iteration f-values), default is 1e-5 |
| `norm` | bool | Center and normalize rows to Euclidean length 1 if True, default is True |
| `verbose` | bool | Function prints progress between iterations if True, default is False |

## Value

Returns a dictionary with the following key-value pairs:

| Key | Value Type | Value |
| --- | --- | --- |
| `loadings` | numpy.ndarray | Loadings of the sparse principal components |
| `f_manpg` | float | Final F-value |
| `x` | numpy.ndarray | Corresponding ndarray in subproblem to the loadings |
| `iter` | int | Total number of iterations executed |
| `sparsity` | float | Number of sparse loadings (loadings == 0) divided by number of all loadings |
| `time` | Number of seconds for execution |

## Authors
 
Justin Huang and Benjamin Jochem

## References

Chen, S., Ma, S., Xue, L., and Zou, H. (2020) "An Alternating Manifold Proximal Gradient Method for Sparse Principal Component Analysis and Sparse Canonical Correlation Analysis" *INFORMS Journal on Optimization* 2:3, 192-208

## Example

See `spca.py` for a more in-depth example.

```python
import numpy as np
from sparsepca import spca_amanpg

n = 4  # columns
d = 500  # dimensions
m = 1000  # sample size
mu = 0.1 * np.ones((n, 1))
f_palm = 1e5

np.random.seed(10)
a = np.random.normal(0, 1, size=(m, d))  # generate random normal 1000x500 matrix
fin_sprout = spca_amanpg(a, mu, 1, f_palm, n=4)
print(f"Finite: {fin_sprout['iter']} iterations with final value {fin_sprout['f_manpg']}, sparsity {fin_sprout['sparsity']}, timediff {fin_sprout['time']}.")

fin_sprout['loadings']

inf_sprout = spca_amanpg(a, mu, np.inf, f_palm, n=4)
print(f"Infinite: {inf_sprout['iter']} iterations with final value {inf_sprout['f_manpg']}, sparsity {inf_sprout['sparsity']}, timediff {inf_sprout['time']}.")

inf_sprout['loadings']
```

